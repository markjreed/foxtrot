#!/bin/bash 
if ! type -p md5 >&/dev/null; then
  md5() {
    md5sum "$@" | awk '{print $1}'
  }
fi
let keep=0 verbose=0
if [[ "$1" == -v ]]; then 
  let verbose=1
  exec 3>&2
  shift
fi
dir=/tmp/foxtrot$$
cd "$(dirname "$(type -p "$0")")"
mkdir -p "$dir"
cp -r [Pp]unishment_*.txt Gemfile* .bundle vendor compile_*.sh run_*.sh *COM ybc basic "$dir" >&/dev/null
cp compile_*.sh run_*.sh "$dir"
cd "$dir"
IFS=$'\n' read -d '' -a languages < <(jq -r 'to_entries[]|.key+"\t"+.value' <~-/languages.json | sort -k2,2)
for lang in "${languages[@]}"; do
  read ext name <<<"$lang"
  lext="$(tr A-Z a-z <<<"$ext")"
  lname="$(tr A-Z a-z <<<"$name")"
  for f in {p,P}unishment_$ext.txt; do
     if [ -r "$f" ]; then break; fi
  done
  old_f=$f
  f=${f%.txt}
  f=${f//_/.}
  mv "$old_f" "$f"
  lf="$(tr A-Z a-z <<<"$f")"
  old_f="$(tr A-Z a-z <<<"${lf%.$lext}_$lext.txt")"
  if (( $# )); then
    for arg in "$@"; do
      found=0
      case "$(tr A-Z a-z <<<"$arg")" in
        $lext|$lname|$lf|$old_f) found=1; break;;
      esac
    done
    if (( ! found )); then
      continue
    fi
  fi
  echo -n "$name:"
  if [ ! -r "$f" ]; then
    result='[33mSKIP[0m'
  else
    result=
    compile=()
    run=()
    in=
    if [ -x "compile_$ext.sh" ]; then
      compile=("./compile_$ext.sh" "$f" )
    fi
    if [ -x "run_$ext.sh" ]; then
      run=("./run_$ext.sh" "$f" )
    else 
      case "$ext" in
      a68) run=(a68g "$f");;
      adb) compile=(gnat make "$f"); run=("./${f%.$ext}");;
      awk) run=(awk -f ./"$f");;
      b) run=(./a.out);;
      bas) run=(basic "$f");;
      batsh) if ! type -p batsh >/dev/null; then result='[33mSKIP[0m'; else  compile=(bash -c "batsh bash '$f' >batsh.out"); run=(bash ./batsh.out); fi;;
      bef) run=(bef -q "$f");;
      bf) run=(bf); in="$f";;
      c) compile=(gcc "$f" ); run=(./a.out);;
      cl) run=(clisp "$f");;
      clj) run=(lein exec "$f");;
      cob) compile=(cobc -x "$f"); run=("./${f%.$ext}");;
      cpp) compile=(g++ "$f" ); run=(./a.out);;
      cs) compile=(mcs "$f"); run=(mono "${f%.*}.exe");;
      d) compile=(dmd "$f" ); run=("./${f%.$ext}");;
      dc) run=(dc -f "$f");;
      dylan) run=(rundylan "$f");;
      erl) run=(escript "$f");;
      exs) run=(elixir "$f");;
      f) compile=(gfortran "$f" ); run=(./a.out);;
      fr) compile=(fregec "$f" ); run=(frege Punishment);;
      4th) run=(gforth "$f");;
      go) run=(go run "$f");;
      hs) run=(runhaskell "$f");;
      i) compile=(ick -b "$f"); run=("./${f%.$ext}");;
      ico)  run=(icon "$f");;
      idr) compile=(idris -o a.out "$f"); run=(./a.out);;
      inf) compile=(inform6 "$f"); run=(dfrotz -Rmp "${f%.$ext}.z5");;
      j) run=(jconsole "$f");;
      java) compile=(javac "$f"); run=(java Punishment);;
      lasso) run=(lasso9 "$f");;
      lol) run=(lci "$f");;
      lsl) result='[33mSKIP[0m';;
      m) compile=(clang -framework Foundation "$f"); run=(./a.out);;
      mod) compile=(gm2 -fno-pth -flibs=log,pim "$f"); run=(./a.out);;
      m3) compile=(cm3); run=(bash -c "./*/prog"); rm -f punishment.*;;
      ml) run=(ocaml  "$f");;
      nim) run=(nim --verbosity:0 --run compile "$f");;
      occ) compile=(kroc "$f" -lcourse); run=(./punishment);;
      p) compile=(fpc "$f" ); run=("./${f%.$ext}");;
      p4) run=(perl4 "$f");;
      p5) run=(perl "$f");;
      p5i) run=(perl5i "$f");;
      p6) run=(perl6 "$f");;
      pl) run=(swipl -q -g main -l "$f");;
      ps) result='[33mSKIP[0m';;
      py) run=(python "$f");;
      py3) run=(python3 "$f");;
      r)  run=(r -q --slave -f "$f");;
      rb) run=(ruby "$f");;
      reb) run=(rebol -q "$f");;
      rkt) run=(racket "$f");;
      rs) compile=(rustc "$f"); run=("./${f%.$ext}");;
      scm) run=(racket -f "$f");;
      semi) run=(semicolon "$f");;
      sim) compile=(cim "$f"); run=("./${f%.$ext}");;
      sl) run=(slsh "$f");;
      sml) compile=(mlton "$f"); run=("./${f%.$ext}");;
      sno) run=(snobol4 "$f");;
      spl) run=(splrun "$f");;
      sq) run=(subleq "$f");;
      st) run=(gst "$f");;
      tcl) run=(tclsh "$f");;
      unl) run=(unlambda "$f");;
      vala) compile=(valac "$f"); run=("./${f%.$ext}");;
      vq) run=(varaq "$f");;
      yorick) run=(yorick -batch "$f");;
      *) if type -t "$ext"  >/dev/null; then
           run=("$ext" "$f")
         else
           result='[33mSKIP[0m'
         fi;;
      esac 
    fi
    if [ -z "$result" ]; then
      rm -f punishment a.out
      if (( verbose )); then echo $'\n\t'"${compile[@]}" >&3; fi 
      if "${compile[@]}" >/dev/null 2>&1; then
        if (( verbose )); then echo $'\t'"${run[@]}" >&3; fi 
        if [ -n "$in" ]; then
           "${run[@]}" <"$in"
        else
           "${run[@]}"
        fi
      fi 2>$ext.err >$ext.out 
      if (( $? == 123 )); then
        result='[33mSKIP[0m'
      elif [ "$(sed -e $'s/^[ \t]*//' -e $'s/[ \t]*$//' "$ext.out" | md5 | awk '{print $NF}')" == 6b1f79859ffd35ffe4930ce7d4a1848c ]; then
        result='[32mPASS[0m'
      else
        result='[31mFAIL[0m'
        keep=1
      fi
    fi
    echo "$result"
  fi
done 
if (( keep )); then
  echo "Files are in $dir"
else
  rm -rf "$dir"
fi

